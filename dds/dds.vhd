-- File: dds.vhd
-- Generated by MyHDL 1.0dev
-- Date: Sun May 22 16:02:51 2016


library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use std.textio.all;

use work.pck_myhdl_10.all;

entity dds is
    port (
        clk_i: in std_logic;
        rst_i: in std_logic;
        ena_i: in std_logic;
        phase_i: in unsigned(10 downto 0);
        phase_load_i: in std_logic;
        phase_incr_i: in unsigned(10 downto 0);
        di_o: out unsigned(8 downto 0);
        dq_o: out unsigned(8 downto 0)
    );
end entity dds;
-- Parameterizable DDS solution.

architecture MyHDL of dds is



signal phase_acc: unsigned(10 downto 0);
signal di: unsigned(8 downto 0);
signal dq: unsigned(8 downto 0);

begin




-- Read the waveform look-up table.
DDS_DDS_WAVE_ROM: process (phase_acc) is
begin
    di <= wave_rom(to_integer(phase_acc));
    dq <= wave_rom(to_integer(signed(resize(phase_acc, 12)) + ((2 ** 12) / 4)));
end process DDS_DDS_WAVE_ROM;

-- Calculate the phase accumulator.
DDS_DDS_PHASE_ACC: process (clk_i) is
begin
    if rising_edge(clk_i) then
        if (rst_i = '1') then
            phase_acc <= to_unsigned(000, 11);
        else
            if bool(ena_i) then
                if bool(phase_load_i) then
                    phase_acc <= phase_i;
                else
                    phase_acc <= (phase_acc + phase_incr_i);
                end if;
            end if;
        end if;
    end if;
end process DDS_DDS_PHASE_ACC;

-- Create DDS output.
DDS_DDS_LOGIC: process (clk_i) is
begin
    if rising_edge(clk_i) then
        if (rst_i = '1') then
            di_o <= to_unsigned(000, 9);
            dq_o <= to_unsigned(000, 9);
        else
            if bool(ena_i) then
                di_o <= di;
                dq_o <= dq;
            end if;
        end if;
    end if;
end process DDS_DDS_LOGIC;

end architecture MyHDL;
